# Vers√£o do Arquivo Compose
version: '3'

# Criando Servi√ßos, mapeamento de portas e configura√ß√£o de politica de reinicializa√ß√£o
services:
  frontend:
    build: frontend/    # Especificamos o contexto, ou seja, a pasta onde est√° o Dockerfile.
    restart: always
    ports:
      - 3000:3000
    depends_on:
      - backend
    volumes:
      - ./logs:/var/log/frontend

  backend:
    build: backend/     # Mesmo caso aqui.
    restart: always
    ports:
      - 3001:3001
    environment:
      - DB_HOST=database # O servi√ßo backend agora possui uma vari√°vel de ambiente chamada DB_HOST, que poder√° ser utilizada pelo servidor para se conectar ao banco de dados.
    depends_on:
      - database

  database:
    image: betrybe/docker-compose-example-database:v1    # Especificamos a Imagem Docker diretamente.
    restart: always
    volumes:
      - dados-do-banco:/data/db

volumes:
  dados-do-banco:
# Nosso arquivo vai funcionar como se estiv√©ssemos executando o comando docker build para o back-end e o front-end. Logo depois, tr√™s vezes o comando docker run, um vez para cada servi√ßo.

# E se o container der problema?
# Pensando nisso, devemos configurar uma pol√≠tica de reinicializa√ß√£o (mais detalhes no arquivo resumo.md)

# Depend√™ncia:
# Cada servi√ßo do nosso arquivo docker-compose.yaml recebeu a chave depends_on, que √© uma lista de quais servi√ßos o Compose deve executar primeiro, antes de executar o servi√ßo atual. Nesse exemplo, os servi√ßos ser√£o iniciados respeitando a ordem que especificamos: primeiro o servi√ßo database ser√° iniciado, depois o servi√ßo backend e finalmente o servi√ßo frontend!

# Agora que criamos nosso primeiro arquivo Compose, est√° na hora de finalmente execut√°-lo e orquestrar nossos containers! Bora l√°? üêã